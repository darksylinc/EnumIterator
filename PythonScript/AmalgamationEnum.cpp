// EnumIterator.py AUTOGENERATED FILE. ** DO NOT EDIT ** Run "python2 Run.py"

#include <algorithm>
#include <stdexcept>

const std::string BLANKSTRING = "";

#include "ExampleHeader.h"
namespace Test
{
namespace Inner
{
ExampleContiguous::EnumData ExampleContiguous::mSortedByEnum[3+1] =
{
ExampleContiguous::EnumData( One,		"One" )
ExampleContiguous::EnumData( Two,		"Two" )
ExampleContiguous::EnumData( Three,		"Three" )
ExampleContiguous::EnumData( One,		"__INVALID" )
};

ExampleContiguous::EnumData ExampleContiguous::mSortedByString[3+1] =
{ExampleContiguous::EnumData( Three,		"Three" )
ExampleContiguous::EnumData( Two,		"Two" )
ExampleContiguous::EnumData( One,		"One" )
ExampleContiguous::EnumData( One,		"__INVALID" )
}};

//---------------------------------------------------------------------------------------
ExampleContiguousEnum::EnumData::EnumData( ExampleContiguous _enumValue,
										   const std::string &_enumString ) :
	enumValue( _enumValue ),
	enumString( _enumString )
{
}
//---------------------------------------------------------------------------------------
struct ExampleContiguousEnum::OrderByEnum
{
	bool operator () ( const ExampleContiguousEnum::EnumData &_l, ExampleContiguous _r ) const
	{
		return _l.enumValue < _r;
	}

	bool operator () ( ExampleContiguous _l, const ExampleContiguousEnum::EnumData &_r ) const
	{
		return _l < _r.enumValue;
	}

	bool operator () ( const ExampleContiguousEnum::EnumData &_l, int _r ) const
	{
		return _l.enumValue < _r;
	}

	bool operator () ( int _l, const ExampleContiguousEnum::EnumData &_r ) const
	{
		return _l < _r.enumValue;
	}
};
//---------------------------------------------------------------------------------------
struct ExampleContiguousEnum::OrderByStr
{
	bool operator () ( const ExampleContiguousEnum::EnumData &_l, const std::string &_r ) const
	{
		return _l.enumString < _r;
	}

	bool operator () ( const std::string &_l, const ExampleContiguousEnum::EnumData &_r ) const
	{
		return _l < _r.enumString;
	}
};
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
int ExampleContiguousEnum::minValue()
{
	return mSortedByEnum[0].enumValue;
}
//---------------------------------------------------------------------------------------
int ExampleContiguousEnum::maxValue()
{
	return mSortedByEnum[3-1].enumValue;
}
//---------------------------------------------------------------------------------------
size_t ExampleContiguousEnum::count()
{
	return 3;
}
//---------------------------------------------------------------------------------------
bool ExampleContiguousEnum::find( const std::string &strValue, ExampleContiguous &outValue )
{
	const EnumData* itor = std::lower_bound( &mSortedByString[0],
											 &mSortedByString[3],
											 strValue, OrderByStr() );

	if( itor != &mSortedByString[3] && itor->enumString == strValue )
	{
		outValue = itor->enumValue;
		return true;
	}
	else
	{
		return false;
	}
}
//---------------------------------------------------------------------------------------
ExampleContiguous ExampleContiguousEnum::find( const std::string &strValue )
{
	ExampleContiguous retVal;
	const bool bFound = find( strValue, retVal );
	if( !bFound )
	{
		throw std::invalid_argument( "String: " + strValue +
									 " is not a valid enum of type ExampleContiguous" );
	}

	return retVal;
}

//---------------------------------------------------------------------------------------
bool ExampleContiguousEnum::isValidValue( int value )
{
	return minValue() >= idx && idx <= maxValue();
}
//---------------------------------------------------------------------------------------
const std::string& ExampleContiguousEnum::get( ExampleContiguous value )
{
	const int idx = value - mSortedByEnum[0].enumValue;
	if( idx >= count() )
		return BLANKSTRING;

	return mSortedByEnum[idx].enumString;
}
//---------------------------------------------------------------------------------------
const std::string& ExampleContiguousEnum::find( ExampleContiguous value )
{
	return get( value );
}
}
}

#include "ExampleHeader2.h"
